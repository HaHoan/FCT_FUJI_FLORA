-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel MegaCore Function License Agreement, or other
-- applicable license agreement, including, without limitation,
-- that your use is for the sole purpose of programming logic
-- devices manufactured by Intel and sold by Intel or its
-- authorized distributors.  Please refer to the applicable
-- agreement for further details.


-- Generated by Quartus Prime Version 17.0 (Build Build 595 04/25/2017)
-- Created on Thu Apr 12 15:26:07 2018

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.std_logic_arith.all;

--  Entity Declaration

ENTITY I2C_CLK_OUT_8 IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
CLK24 : IN STD_LOGIC;
RESET : IN STD_LOGIC;
ADR : IN STD_LOGIC_VECTOR(15 downto 0);
DATI : IN STD_LOGIC_VECTOR(7 downto 0);
RDe : IN STD_LOGIC;
WRe : IN STD_LOGIC;
DATO : OUT STD_LOGIC_VECTOR(7 downto 0);
CLKO : OUT STD_LOGIC_VECTOR(7 downto 0);
TPOUT : OUT STD_LOGIC_VECTOR(15 downto 0)
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END I2C_CLK_OUT_8;


--  Architecture Body

ARCHITECTURE I2C_CLK_OUT_8_architecture OF I2C_CLK_OUT_8 IS

	signal OutEnable			: std_logic_vector ( 7 downto 0 );	-- Enable flag
	signal Res					: std_logic;								-- internal reset Hi Active
	signal fStart				: std_logic;
	signal fEnd					: std_logic;
	
	Type Buffers is array( 0 to 7 ) of std_logic_vector( 15 downto 0 );
	signal CountNow			: Buffers;
	signal WidthX				: Buffers;
	signal UpX					: Buffers;
	signal DownX				: Buffers;
	signal Count				: Buffers;
	signal StartCnt			: Buffers;
	signal GenCount			: Buffers;
	signal eof					: std_logic_vector( 7 downto 0 );

	-- for BASE CLOCK module 
	signal BaseClkWidth		: std_logic_vector( 15 downto 0 );		-- 24MHz x 12 = 0.5usec
	signal BaseClkCnt			: std_logic_vector( 15 downto 0 );
	signal BaseClk				: std_logic;
	
	-- OUTCTL --
	COMPONENT	CK_GEN
		port
		(
			RESET		:	IN		STD_LOGIC;
			RES		:	IN		STD_LOGIC;
			CLK		:	IN		STD_LOGIC;
			START		:	IN		STD_LOGIC;
			COUNT		:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			WIDTHX	:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			UPX		:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			DOWNX		:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			STARTC	:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			OUTEN		:	IN		STD_LOGIC;
			
			CKO		:	OUT	STD_LOGIC;
			COUNTNOW	:	OUT	STD_LOGIC_VECTOR ( 15 downto 0 );
			fEND		:	OUT	STD_LOGIC;
			GENCOUNT	:	OUT	STD_LOGIC_VECTOR ( 15 downto 0 )
		);
	END COMPONENT;

	
BEGIN
	
	C0:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(0), WidthX(0), UpX(0), DownX(0), StartCnt(0), OutEnable(0), CLKO(0), CountNow(0), eof(0), GenCount(0) );
	C1:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(1), WidthX(1), UpX(1), DownX(1), StartCnt(1), OutEnable(1), CLKO(1), CountNow(1), eof(1), GenCount(1) );
	C2:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(2), WidthX(2), UpX(2), DownX(2), StartCnt(2), OutEnable(2), CLKO(2), CountNow(2), eof(2), GenCount(2) );
	C3:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(3), WidthX(3), UpX(3), DownX(3), StartCnt(3), OutEnable(3), CLKO(3), CountNow(3), eof(3), GenCount(3) );
	C4:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(4), WidthX(4), UpX(4), DownX(4), StartCnt(4), OutEnable(4), CLKO(4), CountNow(4), eof(4), GenCount(4) );
	C5:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(5), WidthX(5), UpX(5), DownX(5), StartCnt(5), OutEnable(5), CLKO(5), CountNow(5), eof(5), GenCount(5) );
	C6:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(6), WidthX(6), UpX(6), DownX(6), StartCnt(6), OutEnable(6), CLKO(6), CountNow(6), eof(6), GenCount(6) );
	C7:CK_GEN
		Port map ( RESET, RES, BaseClk, fStart, Count(7), WidthX(7), UpX(7), DownX(7), StartCnt(7), OutEnable(7), CLKO(7), CountNow(7), eof(7), GenCount(7) );
	
	
	
	
	
	
	
	
	-- REG W/R process --
	process (
		RESET
	)
	begin
		if ( RESET = '0' ) then
			OutEnable 	<= ( others => '0' );		-- Enable 0 Stop
			
			Res			<= '0';							-- Internal Rest off
			fStart		<= '0';
			fEnd			<= '0';
			
			for i in 0 to 7 loop
				WidthX ( i )	<= ( others => '0' );
				Upx ( i )		<= ( others => '0' );
				Downx ( i )		<= ( others => '0' );
				Count ( i )		<= ( others => '0' );
				StartCnt ( i )	<= ( others => '0' );
			end loop;
			
			BaseClkWidth		<= X"000C";		-- 24MHz x 12 = 0.5usec
			
		-- READ --
		elsif	( RDe = '0' and WRe = '1' ) then
			-- 02:80 --
			if		( X"0280" = ADR ) then
				DATO ( 7 )	<= Res;					-- Internal Reset Status
				DATO ( 6 )	<= '0';					-- N/A
				DATO ( 5 )	<= '0';					-- N/A
				DATO ( 4 )	<= '0';					-- N/A
				DATO ( 3 )	<= fEnd;					-- End Flag Status
				DATO ( 2 )	<= '0';					-- N/A
				DATO ( 1 )	<= '0';					-- N/A
				DATO ( 0 )	<= fStart;				-- Start Flag Status
			elsif ( X"0281" = ADR ) then
				DATO			<= OutEnable;
			elsif ( X"0282" <= ADR and ADR <= X"0283" ) then
				DATO			<= BaseClkWidth ( ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 0 ) ) * 8 ) );
			elsif ( X"0284" <= ADR and ADR <= X"0285" ) then
				DATO			<= BaseClkCnt	 ( ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 0 ) ) * 8 ) );
			elsif ( X"0200" <= ADR and ADR <= X"027B" ) then
				case ADR ( 3 downto 0 ) is
				-- CountNow
					when X"0" =>	DATO		<= CountNow	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"1" =>	DATO		<= CountNow	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- Width
					when X"2" =>	DATO		<= WidthX	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"3" =>	DATO		<= WidthX	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- Up
					when X"4" =>	DATO		<= Upx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"5" =>	DATO		<= Upx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- Down
					when X"6" =>	DATO		<= Downx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"7" =>	DATO		<= Downx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- Count
					when X"8" =>	DATO		<= Count		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"9" =>	DATO		<= Count		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- Start
					when X"A" =>	DATO		<= StartCnt	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 );
					when X"B" =>	DATO		<= StartCnt	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 );
				-- other
					when others=>	DATO		<= X"CC";
				end case;
			else
				DATO <= ( others => 'Z' );
			end if;
			
		-- WRITE --
		elsif ( RDe = '1' and WRe = '0' ) then
			if		( X"0280" = ADR ) then
				Res			<= DATI ( 7 );
				fEnd			<= DATI ( 3 );
				fStart		<= DATI ( 0 );
			elsif	( X"0281" = ADR ) then
				OutEnable	<= DATI;
			elsif ( X"0282" <= ADR and ADR <= X"0283" ) then
				BaseClkWidth ( ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 0 ) ) * 8 ) ) <= DATI;
			elsif ( X"0284" <= ADR and ADR <= X"0285" ) then
				NULL;
			elsif ( X"0200" <= ADR and ADR <= X"027B" ) then
				case ADR ( 3 downto 0 ) is
				-- CountNow
					when X"0" =>	NULL;
					when X"1" =>	NULL;
				-- Width
					when X"2" =>	WidthX	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 ) <= DATI;
					when X"3" =>	WidthX	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 ) <= DATI;
				-- Up
					when X"4" =>	Upx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 ) <= DATI;
					when X"5" =>	Upx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 ) <= DATI;
				-- Down
					when X"6" =>	Downx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 ) <= DATI;
					when X"7" =>	Downx		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 ) <= DATI;
				-- Count
					when X"8" =>	Count		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 ) <= DATI;
					when X"9" =>	Count		( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 ) <= DATI;
				-- Start
					when X"A" =>	StartCnt	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) (  7 downto 0 ) <= DATI;
					when X"B" =>	StartCnt	( CONV_INTEGER( ADR ( 7 downto 4 ) ) ) ( 15 downto 8 ) <= DATI;
				-- other
					when others=>	NULL;
				end case;
			else
				NULL;
			end if;
		else
			DATO <= ( others => 'Z' );
		end if;
	end process;



	-- Base Clock Module @ 24MHz -- 
	process (
		RESET,
		CLK24
	)
	begin
		if ( RESET = '0' ) then
			BaseClkCnt	<= X"0000";
			BaseClk		<= '0';
		elsif ( CLK24'event and CLK24 = '1' ) then
			BaseClkCnt <= BaseClkCnt + '1';
			
			if ( BaseClkCnt >= (BaseClkWidth-1) ) then
				BaseClk <= not BaseClk;
				BaseClkCnt <= (others=>'0');		-- 0 clear
			end if;
			
		end if;
	end process;


	
	
	
	
	
	
	
END I2C_CLK_OUT_8_architecture;
