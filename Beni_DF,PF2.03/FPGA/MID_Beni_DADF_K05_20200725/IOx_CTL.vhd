-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel MegaCore Function License Agreement, or other
-- applicable license agreement, including, without limitation,
-- that your use is for the sole purpose of programming logic
-- devices manufactured by Intel and sold by Intel or its
-- authorized distributors.  Please refer to the applicable
-- agreement for further details.


-- Generated by Quartus Prime Version 17.0 (Build Build 595 04/25/2017)
-- Created on Sat Apr 21 10:01:50 2018

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.std_logic_arith.all;


--  Entity Declaration

ENTITY IOx_CTL IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
RESET : IN STD_LOGIC;
ADR : IN STD_LOGIC_VECTOR(15 downto 0);
RDe : IN STD_LOGIC;
WRe : IN STD_LOGIC;
DATI : IN STD_LOGIC_VECTOR(7 downto 0);
DATO : OUT STD_LOGIC_VECTOR(7 downto 0);
IOX : INOUT STD_LOGIC_VECTOR(7 downto 0);
EXIN : IN STD_LOGIC;
PWBA_OK : OUT STD_LOGIC
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END IOx_CTL;


--  Architecture Body

ARCHITECTURE IOx_CTL_architecture OF IOx_CTL IS
	SIGNAL INVERT	: STD_LOGIC_VECTOR ( 7 downto 0 );
	SIGNAL PUSPLL	: STD_LOGIC_VECTOR ( 7 downto 0 );
	SIGNAL OUTPEN	: STD_LOGIC_VECTOR ( 7 downto 0 );
	SIGNAL OUTPDT	: STD_LOGIC_VECTOR ( 7 downto 0 );
	SIGNAL OUTTMP	: STD_LOGIC_VECTOR ( 7 downto 0 );
	SIGNAL OUTTMP2	: STD_LOGIC_VECTOR ( 7 downto 0 );
	
	-- OUTCTL --
	COMPONENT	OUTCTL
		port
		(
			INP, INV, PP, nOE			: in	std_logic;
			OUTP							: out	std_logic
		);
	END COMPONENT;
	
	signal D_Hiz	: STD_LOGIC;
	signal DATA_O	: STD_LOGIC_VECTOR ( 7 downto 0 );
	
	
	signal UpOE0Reg	: std_logic_vector ( 7 downto 0 );
	signal UpOE1Reg	: std_logic_vector ( 7 downto 0 );
	signal DnOE0Reg	: std_logic_vector ( 7 downto 0 );
	signal DnOE1Reg	: std_logic_vector ( 7 downto 0 );
	
	signal VIN0UP		: std_logic;
	signal VIN1UP		: std_logic;
	signal VIN0DN		: std_logic;
	signal VIN1DN		: std_logic;
	
BEGIN
	DATO <= ( others => 'Z' ) when D_Hiz = '1' else DATA_O;

	PWBA_OK <= IOX ( 6 );	-- IOX[6] is IOA2 for Upper

	process ( 
		RESET,
		RDe,
		WRe
	)
	begin
		
		if ( RESET = '0' ) then
		-- リセット
			INVERT	<= "00000000";				-- 初期値 正論理(0)
			PUSPLL	<= "00000000";				-- 初期値 オープンドレイン(0)
			OUTPEN	<= "01000100";				-- 初期値 入力(1) / 出力(0)		IOA3:O IOA2:I IOA1:O IOA:O
			OUTPDT	<= "00110011";				-- 初期値 Lo(0) / Hi(1)
			
			
			UpOE0Reg <= "00000110";				-- Bit2: Vin1使用ﾌﾗｸﾞ(1) / Bit1: Vin0使用ﾌﾗｸﾞ(1) 
			UpOE1Reg <= "00000110";
			DnOE0Reg <= "00000110";
			DnOE1Reg <= "00000110";
			
			OUTTMP ( 2 ) <= '1';					-- nouse
			OUTTMP ( 3 ) <= '1';					-- LED
			OUTTMP ( 6 ) <= '1';					-- nouse
			OUTTMP ( 7 ) <= '1';					-- LED		TIO(/LED3) MOT(/LED3) is IOA3
			
			D_Hiz		<= '1';

		elsif ( RDe = '0' and WRe = '1' ) then
		-- リード
			case ADR is
				when X"F300"=>		-- 入力ポート
					DATA_O <= IOX;
					D_Hiz <= '0';
				when X"F301"=>		-- 出力ポート
					DATA_O <= OUTPDT;
					D_Hiz <= '0';
				when X"F302"=> 	-- 反転レジスタ
					DATA_O <= INVERT;
					D_Hiz <= '0';
				when X"F303"=> 	-- プッシュプルレジスタ
					DATA_O <= PUSPLL;
					D_Hiz <= '0';
				when X"F304"=> 	-- アウトプットイネーブル
					DATA_O <= OUTPEN;
					D_Hiz <= '0';
				when X"F305"=>
					DATA_O ( 7 )				<= OUTTMP ( 7 );
					DATA_O ( 6 downto 0 )	<= ( others=>'0' );
					
				when X"F400" =>
					DATA_O <= DnOE0Reg;
					D_Hiz <= '0';
				when X"F401" =>
					DATA_O <= DnOE1Reg;
					D_Hiz <= '0';
				when X"F402" =>
					DATA_O <= UpOE0Reg;
					D_Hiz <= '0';
				when X"F403" =>
					DATA_O <= UpOE1Reg;
					D_Hiz <= '0';
					
					
				when others	=>
					D_Hiz <= '1';
			end case;
		
		elsif ( RDe = '1' and WRe = '0' ) then
		-- ライト
			case ADR is
				when X"F300"=>		-- 入力ポート
					NULL;
				when X"F301"=>		-- 出力ポート
					OUTPDT <= DATI;
					
					DnOE0Reg ( 0 ) <= not DATI ( 0 );
					DnOE1Reg ( 0 ) <= not DATI ( 0 );
					UpOE0Reg ( 0 ) <= not DATI ( 4 );
					UpOE1Reg ( 0 ) <= not DATI ( 4 );
					
				when X"F302"=> 	-- 反転レジスタ
--					INVERT <= DATI;	-- 2018.06.19 廃止 変更不可とする
				when X"F303"=> 	-- プッシュプルレジスタ
--					PUSPLL <= DATI;	-- 2018.06.19 廃止 変更不可とする
				when X"F304"=> 	-- アウトプットイネーブル
					OUTPEN <= DATI;
				
				when X"F305"=>
					OUTTMP( 7 ) <= DATI ( 7 );
					
				when X"F400" =>
					DnOE0Reg <= DATI;
					OUTPDT ( 0 ) <= not DATI ( 0 );
					
				when X"F401" =>
					DnOE1Reg <= DATI;
					OUTPDT ( 0 ) <= not DATI ( 0 );

				when X"F402" =>
					UpOE0Reg <= DATI;
					OUTPDT ( 4 ) <= not DATI ( 4 );
					
				when X"F403" =>
					UpOE1Reg <= DATI;
					OUTPDT ( 4 ) <= not DATI ( 4 );
					
				when others	=>
					NULL;
			end case;
			D_Hiz <= '1';
		else
		-- 規定外
			D_Hiz	<= '1';
		end if;

	end process;
	

	
	-- UP OEx
	VIN0UP <= not IOX ( 6 );	-- IOA1	-- VIN Active Hiへ変換 1=DUT ON / 0=DUT OFF
	VIN1UP <= '0' when OUTPEN ( 7 ) = '0' else not IOX ( 7 );
	VIN0DN <= not IOX ( 2 );
	VIN1DN <= '0' when OUTPEN ( 3 ) = '0' else not IOX ( 3 );

	-- IOA3 が LED点灯用のOUTPUTでない場合のみVIN1UP/DNへIOA3の反転を代入（VIN1を使用する場合のゲート処理)
	
	-- UP OE0
	OUTTMP ( 4 ) <= '0'
	when
		(
			UpOE0Reg ( 5 downto 4 ) = "00"	-- 4 or
			-- 通常使用時
				and 
					(	(
							( UpOE0Reg ( 1 ) = '1' and VIN0UP = '1' )		-- VIN0 使用ﾌﾗｸﾞON and VIN0_U (L)
						)
						or
						(
							( UpOE0Reg ( 3 ) = '1' and EXIN = '1' )		-- 外部信号使用ﾌﾗｸﾞ ON and 外部信号 H	--(現在未使用)
						)
						or
						(
							( UpOE0Reg ( 0 ) = '1' )							-- SOFT強制ON
						)
					)
		)
		or
		(
			UpOE0Reg ( 5 downto 4 ) = "01" -- 4 and
			-- 使用時はEXINを1に設定する事(外部端子)でかつソフト強制ONも1にすること
			and
					(
						(
							( UpOE0Reg ( 1 ) = '1' and VIN0UP = '1' )
						)
						and
						(
							( UpOE0Reg ( 2 ) = '1' and VIN1UP = '1' )
						)
						and
						(
							( UpOE0Reg ( 3 ) = '1' and EXIN = '1' )
						)
						and
						(
							( UpOE0Reg ( 0 ) = '1' )
						)
					)
		)
	else
		'1';
		
	-- UP OE1
	OUTTMP ( 5 ) <= '0'
	when
		(
			UpOE1Reg ( 5 downto 4 ) = "00"	-- 4 or
				and 
					(	(
							( UpOE1Reg ( 2 ) = '1' and VIN1UP = '1' )
						)
						or
						(
							( UpOE1Reg ( 3 ) = '1' and EXIN = '1' )
						)
						or
						(
							( UpOE1Reg ( 0 ) = '1' )
						)
					)
		)
		or
		(
			UpOE1Reg ( 5 downto 4 ) = "01" -- 4 and
				and
					(
						(
							( UpOE1Reg ( 1 ) = '1' and VIN0UP = '1' )
						)
						and
						(
							( UpOE1Reg ( 2 ) = '1' and VIN1UP = '1' )
						)
						and
						(
							( UpOE1Reg ( 3 ) = '1' and EXIN = '1' )
						)
						and
						(
							( UpOE1Reg ( 0 ) = '1' )
						)
					)
		)
	else
		'1';
		
		
	-- DOWN OE0
	OUTTMP ( 0 ) <= '0'
	when
		(
			DnOE0Reg ( 5 downto 4 ) = "00"	-- 4 or
				and 
					(	(
							( DnOE0Reg ( 1 ) = '1' and VIN0DN = '1' )		-- VIN0 使用ﾌﾗｸﾞON and VIN0_L (L)
						)
						or
						(
							( DnOE0Reg ( 3 ) = '1' and EXIN = '1' )		-- 外部信号使用ﾌﾗｸﾞ ON and 外部信号 H	--(現在未使用)
						)
						or
						(
							( DnOE0Reg ( 0 ) = '1' )							-- SOFT強制ON
						)
					)
		)
		or
		(
			DnOE0Reg ( 5 downto 4 ) = "01" -- 4 and
				and
					(
						(
							( DnOE0Reg ( 1 ) = '1' and VIN0DN = '1' )
						)
						and
						(
							( DnOE0Reg ( 2 ) = '1' and VIN1DN = '1' )
						)
						and
						(
							( DnOE0Reg ( 3 ) = '1' and EXIN = '1' )
						)
						and
						(
							( DnOE0Reg ( 0 ) = '1' )
						)
					)
		)
	else
		'1';
		
	-- DOWN OE1
	OUTTMP ( 1 ) <= '0'
	when
		(
			DnOE1Reg ( 5 downto 4 ) = "00"	-- 4 or
				and 
					(	(
							( DnOE1Reg ( 2 ) = '1' and VIN1DN = '1' )		-- VIN1 使用ﾌﾗｸﾞON and VIN1_L (L)
						)
						or
						(
							( DnOE1Reg ( 3 ) = '1' and EXIN = '1' )		-- 外部信号使用ﾌﾗｸﾞ ON and 外部信号 H	--(現在未使用)
						)
						or
						(
							( DnOE1Reg ( 0 ) = '1' )							-- SOFT強制ON
						)
					)
		)
		or
		(
			DnOE0Reg ( 5 downto 4 ) = "01" -- 4 and
				and
					(
						(
							( DnOE1Reg ( 1 ) = '1' and VIN0DN = '1' )
						)
						and
						(
							( DnOE1Reg ( 2 ) = '1' and VIN1DN = '1' )
						)
						and
						(
							( DnOE1Reg ( 3 ) = '1' and EXIN = '1' )
						)
						and
						(
							( DnOE1Reg ( 0 ) = '1' )
						)
					)
		)
	else
		'1';
		
	
	
	
	
	
-- UP OE0
	IOX ( 4 ) <= 'Z'
		when
			( OUTPEN ( 4 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 4 ) = '0' and PUSPLL ( 4 ) = '0' and INVERT ( 4 ) = '0' and OUTTMP ( 4 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 4 ) = '0' and PUSPLL ( 4 ) = '0' and INVERT ( 4 ) = '1' and OUTTMP ( 4 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 4 );
	
-- UP OE1
	IOX ( 5 ) <= 'Z'
		when
			( OUTPEN ( 5 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 5 ) = '0' and PUSPLL ( 5 ) = '0' and INVERT ( 5 ) = '0' and OUTTMP ( 5 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 5 ) = '0' and PUSPLL ( 5 ) = '0' and INVERT ( 5 ) = '1' and OUTTMP ( 5 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 5 );

-- UP VIN0	基本Read(Z)
	IOX ( 6 ) <= 'Z'
		when
			( OUTPEN ( 6 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 6 ) = '0' and PUSPLL ( 6 ) = '0' and INVERT ( 6 ) = '0' and OUTTMP ( 6 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 6 ) = '0' and PUSPLL ( 6 ) = '0' and INVERT ( 6 ) = '1' and OUTTMP ( 6 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 6 );
	
-- UP VIN1	基本Read(Z)
	IOX ( 7 ) <= 'Z'
		when
			( OUTPEN ( 7 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 7 ) = '0' and PUSPLL ( 7 ) = '0' and INVERT ( 7 ) = '0' and OUTTMP ( 7 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 7 ) = '0' and PUSPLL ( 7 ) = '0' and INVERT ( 7 ) = '1' and OUTTMP ( 7 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 7 );
		
-- Down OE0
	IOX ( 0 ) <= 'Z'
		when
			( OUTPEN ( 0 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 0 ) = '0' and PUSPLL ( 0 ) = '0' and INVERT ( 0 ) = '0' and OUTTMP ( 0 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 0 ) = '0' and PUSPLL ( 0 ) = '0' and INVERT ( 0 ) = '1' and OUTTMP ( 0 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 0 );

-- Down OE1
	IOX ( 1 ) <= 'Z'
		when
			( OUTPEN ( 1 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 1 ) = '0' and PUSPLL ( 1 ) = '0' and INVERT ( 1 ) = '0' and OUTTMP ( 1 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 1 ) = '0' and PUSPLL ( 1 ) = '0' and INVERT ( 1 ) = '1' and OUTTMP ( 1 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 1 );

-- Down VIN0	基本READ(Z)
	IOX ( 2 ) <= 'Z'
		when
			( OUTPEN ( 2 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 2 ) = '0' and PUSPLL ( 2 ) = '0' and INVERT ( 2 ) = '0' and OUTTMP ( 2 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 2 ) = '0' and PUSPLL ( 2 ) = '0' and INVERT ( 2 ) = '1' and OUTTMP ( 2 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 2 );
	
-- DOWN VIN1	基本READ(Z)
	IOX ( 3 ) <= 'Z'
		when
			( OUTPEN ( 3 ) = '1' )																								-- 入力 Z
		or ( OUTPEN ( 3 ) = '0' and PUSPLL ( 3 ) = '0' and INVERT ( 3 ) = '0' and OUTTMP ( 3 ) = '1' )	-- 出力 & OpnDrn & NoInvert & Hi[OReg]
		or ( OUTPEN ( 3 ) = '0' and PUSPLL ( 3 ) = '0' and INVERT ( 3 ) = '1' and OUTTMP ( 3 ) = '0' )	-- 出力 & OpnDrn & Invert   & Lo[OReg]
		else
			OUTTMP ( 3 );
	
	
	
	
END IOx_CTL_architecture;
