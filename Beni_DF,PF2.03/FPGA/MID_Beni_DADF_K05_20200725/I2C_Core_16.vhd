-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2010 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files from any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Altera Program License 
-- Subscription Agreement, Altera MegaCore Function License 
-- Agreement, or other applicable license agreement, including, 
-- without limitation, that your use is for the sole purpose of 
-- programming logic devices manufactured by Altera and sold by 
-- Altera or its authorized distributors.  Please refer to the 
-- applicable agreement for further details.


-- Generated by Quartus II Version 9.1 (Build Build 304 01/25/2010)
-- Created on Thu May 02 14:01:10 2013

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;


-- memo
-- 2018.04.10 miwa ADDRESS 8bit→16Bit変更



--  Entity Declaration

ENTITY I2C_Core_16 IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!

	GENERIC(I2cDevH : STD_LOGIC_VECTOR(3 DOWNTO 0) := X"F");
	PORT
	(
		CLK80 : IN STD_LOGIC;
		CLK24 : IN STD_LOGIC;
		RESET : IN STD_LOGIC;
		SCK : IN STD_LOGIC;
		DATO : IN STD_LOGIC_VECTOR(7 downto 0);
		IAD0 : IN STD_LOGIC;
		IAD1 : IN STD_LOGIC;
		IAD2 : IN STD_LOGIC;
		TP : OUT STD_LOGIC_VECTOR(7 downto 0);
		WRe : OUT STD_LOGIC;
		RDe : OUT STD_LOGIC;
		ADR : OUT STD_LOGIC_VECTOR(15 downto 0);
		DATI : OUT STD_LOGIC_VECTOR(7 downto 0);
		SDT : INOUT STD_LOGIC;
		I2CDevO : OUT STD_LOGIC_VECTOR(7 downto 0)
	);


	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END I2C_Core_16;


--  Architecture Body

ARCHITECTURE I2C_Core_16_architecture OF I2C_Core_16 IS

--	constant	I2C_Dev		: std_logic_vector(4  downto 0) := "01010";
--	constant	I2C_Dev		: std_logic_vector(3  downto 0) := "0100";	--0x40
	signal		I2C_DevAdd	: std_logic_vector(6  downto 0);

	signal		I2C_Command	: std_logic_vector(  7 downto  0 );	-- I2ｽｽｽｽﾞ保趣ｿｽﾚｼﾞｽｽ
	signal		Address		: std_logic_vector( 15 downto  0 );	-- Addressｽﾛ趣ｿｽﾚｼﾞｽｽ
	signal		Data_I		: std_logic_vector(  7 downto  0 );	-- In_Dataｽﾛ趣ｿｽﾚｼﾞｽｽ
	signal		Data_O		: std_logic_vector(  7 downto  0 );	-- Out_Dataｽﾛ趣ｿｽﾚｼﾞｽｽ

	signal		WR_E		: std_logic;						-- Write Enable
	signal		RD_E		: std_logic;						-- Read  Enable


	signal		Reg_00		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0x00
	signal		Reg_01		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0x01
	signal		Reg_02		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0x02
	signal		Reg_03		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0x03
	signal		Reg_F0		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0xF0
	signal		Reg_FF		: std_logic_vector(  7 downto  0 );	-- FPGAﾚｼﾞｽｽ 0xFF

	signal		D_HiZ		: std_logic;				-- SDT ｽoｽﾍ撰ｿｽｽｽ
	signal		O_SDT		: std_logic;				-- SDT Out
	signal		I_SDT		: std_logic;				-- SDT In	(CLK80 Latch)
	signal		I_SCK		: std_logic;				-- SCK In	(CLK80 Latch)
	
	signal		StReq		: std_logic;				-- Start Request
--	10036 signal		SpReq		: std_logic;				-- Stop  Request
	signal		I2C_Res		: std_logic;				-- Reset Request

	signal		I2C_State	: std_logic_vector(  7 downto  0 );

--	10036 signal		DOUT		: std_logic;				-- Debug

	
--Gray Code
	constant	Sta_00	: std_logic_vector(7  downto 0) := "00000000";
	constant	Sta_01	: std_logic_vector(7  downto 0) := "00000001";
	constant	Sta_02	: std_logic_vector(7  downto 0) := "00000011";
	constant	Sta_03	: std_logic_vector(7  downto 0) := "00000010";
	constant	Sta_04	: std_logic_vector(7  downto 0) := "00000110";
	constant	Sta_05	: std_logic_vector(7  downto 0) := "00000111";
	constant	Sta_06	: std_logic_vector(7  downto 0) := "00000101";
	constant	Sta_07	: std_logic_vector(7  downto 0) := "00000100";
	constant	Sta_08	: std_logic_vector(7  downto 0) := "00001100";
	constant	Sta_09	: std_logic_vector(7  downto 0) := "00001101";
	constant	Sta_0A	: std_logic_vector(7  downto 0) := "00001111";
	constant	Sta_0B	: std_logic_vector(7  downto 0) := "00001110";
	constant	Sta_0C	: std_logic_vector(7  downto 0) := "00001010";
	constant	Sta_0D	: std_logic_vector(7  downto 0) := "00001011";
	constant	Sta_0E	: std_logic_vector(7  downto 0) := "00001001";
	constant	Sta_0F	: std_logic_vector(7  downto 0) := "00001000";
	constant	Sta_10	: std_logic_vector(7  downto 0) := "00011000";
	constant	Sta_11	: std_logic_vector(7  downto 0) := "00011001";
	constant	Sta_12	: std_logic_vector(7  downto 0) := "00011011";
	constant	Sta_13	: std_logic_vector(7  downto 0) := "00011010";
	constant	Sta_14	: std_logic_vector(7  downto 0) := "00011110";
	constant	Sta_15	: std_logic_vector(7  downto 0) := "00011111";
	constant	Sta_16	: std_logic_vector(7  downto 0) := "00011101";
	constant	Sta_17	: std_logic_vector(7  downto 0) := "00011100";
	constant	Sta_18	: std_logic_vector(7  downto 0) := "00010100";
	constant	Sta_19	: std_logic_vector(7  downto 0) := "00010101";
	constant	Sta_1A	: std_logic_vector(7  downto 0) := "00010111";
	constant	Sta_1B	: std_logic_vector(7  downto 0) := "00010110";
	constant	Sta_1C	: std_logic_vector(7  downto 0) := "00010010";
	constant	Sta_1D	: std_logic_vector(7  downto 0) := "00010011";
	constant	Sta_1E	: std_logic_vector(7  downto 0) := "00010001";
	constant	Sta_1F	: std_logic_vector(7  downto 0) := "00010000";
	constant	Sta_20	: std_logic_vector(7  downto 0) := "00110000";
	constant	Sta_21	: std_logic_vector(7  downto 0) := "00110001";
	constant	Sta_22	: std_logic_vector(7  downto 0) := "00110011";
	constant	Sta_23	: std_logic_vector(7  downto 0) := "00110010";
	constant	Sta_24	: std_logic_vector(7  downto 0) := "00110110";
	constant	Sta_25	: std_logic_vector(7  downto 0) := "00110111";
	constant	Sta_26	: std_logic_vector(7  downto 0) := "00110101";
	constant	Sta_27	: std_logic_vector(7  downto 0) := "00110100";
	constant	Sta_28	: std_logic_vector(7  downto 0) := "00111100";
	constant	Sta_29	: std_logic_vector(7  downto 0) := "00111101";
	constant	Sta_2A	: std_logic_vector(7  downto 0) := "00111111";
	constant	Sta_2B	: std_logic_vector(7  downto 0) := "00111110";
	constant	Sta_2C	: std_logic_vector(7  downto 0) := "00111010";
	constant	Sta_2D	: std_logic_vector(7  downto 0) := "00111011";
	constant	Sta_2E	: std_logic_vector(7  downto 0) := "00111001";
	constant	Sta_2F	: std_logic_vector(7  downto 0) := "00111000";
	constant	Sta_30	: std_logic_vector(7  downto 0) := "00101000";
	constant	Sta_31	: std_logic_vector(7  downto 0) := "00101001";
	constant	Sta_32	: std_logic_vector(7  downto 0) := "00101011";
	constant	Sta_33	: std_logic_vector(7  downto 0) := "00101010";
	constant	Sta_34	: std_logic_vector(7  downto 0) := "00101110";
	constant	Sta_35	: std_logic_vector(7  downto 0) := "00101111";
	constant	Sta_36	: std_logic_vector(7  downto 0) := "00101101";
	constant	Sta_37	: std_logic_vector(7  downto 0) := "00101100";
	constant	Sta_38	: std_logic_vector(7  downto 0) := "00100100";
	constant	Sta_39	: std_logic_vector(7  downto 0) := "00100101";
	constant	Sta_3A	: std_logic_vector(7  downto 0) := "00100111";
	constant	Sta_3B	: std_logic_vector(7  downto 0) := "00100110";
	constant	Sta_3C	: std_logic_vector(7  downto 0) := "00100010";
	constant	Sta_3D	: std_logic_vector(7  downto 0) := "00100011";
	constant	Sta_3E	: std_logic_vector(7  downto 0) := "00100001";
	constant	Sta_3F	: std_logic_vector(7  downto 0) := "00100000";
	constant	Sta_40	: std_logic_vector(7  downto 0) := "01100000";
	constant	Sta_41	: std_logic_vector(7  downto 0) := "01100001";
	constant	Sta_42	: std_logic_vector(7  downto 0) := "01100011";
	constant	Sta_43	: std_logic_vector(7  downto 0) := "01100010";
	constant	Sta_44	: std_logic_vector(7  downto 0) := "01100110";
	constant	Sta_45	: std_logic_vector(7  downto 0) := "01100111";
	constant	Sta_46	: std_logic_vector(7  downto 0) := "01100101";
	constant	Sta_47	: std_logic_vector(7  downto 0) := "01100100";
	constant	Sta_48	: std_logic_vector(7  downto 0) := "01101100";
	constant	Sta_49	: std_logic_vector(7  downto 0) := "01101101";
	constant	Sta_4A	: std_logic_vector(7  downto 0) := "01101111";
	constant	Sta_4B	: std_logic_vector(7  downto 0) := "01101110";
	constant	Sta_4C	: std_logic_vector(7  downto 0) := "01101010";
	constant	Sta_4D	: std_logic_vector(7  downto 0) := "01101011";
	constant	Sta_4E	: std_logic_vector(7  downto 0) := "01101001";
	constant	Sta_4F	: std_logic_vector(7  downto 0) := "01101000";

	constant	Sta_ED1 : std_logic_vector(7  downto 0) := "10001100";		--Sta_08 -> END
	
BEGIN

SDT <= 'Z' when D_Hiz = '1' else O_SDT;

--TP(4 downto 0) <= Reg_00(4 downto 0);
--TP(7) <= SpReq;
--TP(6) <= StReq;
--TP(5) <= DOUT;


--TP <= Data_O;
TP(0)	<= SDT;
TP(7 downto 1 ) <= (others=>'0');

-- for Ext module
WRe <= WR_E;
RDe <= RD_E;
ADR <= Address;
DATI <= DATA_I;


I2C_DevAdd(6  downto 3) <= I2cDevH;
I2C_DevAdd(2) <= IAD2;
I2C_DevAdd(1) <= IAD1;
I2C_DevAdd(0) <= IAD0;
--I2C_DevAdd(1) <= ID1;
--I2C_DevAdd(0) <= ID0;

I2CDevO(7  downto 1)<= I2C_DevAdd;
I2CDevO(0)<='0';
process( CLK80 , I_SDT ,i_SCK , SDT , SCK , StReq , I2C_Res)
begin

	if(CLK80'event and CLK80 = '1')then
		I_SDT <= SDT;
		I_SCK <= SCK;
		if(I_SCK = '0') then 
			I2C_Res <= '0';
		elsif(StReq = '1') then 
			I2C_Res <= '1';
		else
			I2C_Res <= '0';
		end if;
	end if;
end process;


process( I_SCK , I_SDT , StReq , I2C_Res)
begin
	if(I2C_Res = '1')then
		StReq <= '0'; 
	elsif(I_SDT'event and I_SDT = '0')then
		if(I_SCK = '1') then
			StReq <= '1';	--Start Request
		else
			StReq <= '0'; 
		end if;
	end if;
end process;


--!!! Value assigned, but never read !!!--
--process( I_SCK , I_SDT , SpReq , I2C_Res)
--begin
--	if(I2C_Res = '1')then
--		SpReq <= '0'; 
--	elsif(I_SDT'event and I_SDT = '1')then
--		if(I_SCK = '1') then
--			SpReq <= '1';	--Stop Request
--		else
--			SpReq <= '0'; 
--		end if;
--	end if;
--end process;


process( I_SCK , I_SDT , I2C_Res , I2C_State , Reset ,
		 WR_E , RD_E , DATO
)
begin

	if(Reset = '0') then
		I2C_State <= Sta_00; 
		I2C_Command <= (others => '0');
		Address <= (others => '0');
		Data_I <= (others => '0');
		WR_E <= '1';
		RD_E <= '1';
		DATA_O <= (others => '0');
	elsif(I2C_Res='1')then
		I2C_State <= Sta_01; 
		WR_E <= '1';
		RD_E <= '1';
	elsif(I_SCK'event and I_SCK = '1')then
		case I2C_State is
			when Sta_00 =>		--Nop
				I2C_State <= Sta_00; 
				WR_E <= '1';
				RD_E <= '1';
			when Sta_01 =>		--SCK No1
				I2C_Command(7) <= I_SDT;
				I2C_State <= Sta_02; 
			when Sta_02 =>		--SCK No2
				I2C_Command(6) <= I_SDT;
				I2C_State <= Sta_03; 
			when Sta_03 =>		--SCK No3
				I2C_Command(5) <= I_SDT;
				I2C_State <= Sta_04; 
			when Sta_04 =>		--SCK No4
				I2C_Command(4) <= I_SDT;
				I2C_State <= Sta_05; 
			when Sta_05 =>		--SCK No5
				I2C_Command(3) <= I_SDT;
				I2C_State <= Sta_06; 
			when Sta_06 =>		--SCK No6
				I2C_Command(2) <= I_SDT;
				I2C_State <= Sta_07; 
			when Sta_07 =>		--SCK No7
				I2C_Command(1) <= I_SDT;
				I2C_State <= Sta_08; 
			when Sta_08 =>		--SCK No8
				if(I2c_Command(7 downto 1) = I2C_DevAdd)then	-- ｽｽｽﾌデｽoｽCｽXｽｽｽﾄばれた
					I2C_Command(0) <= I_SDT;
					if(I_SDT = '0')then							-- Write 
						I2C_State <= Sta_09; 
					else										-- Read
						I2C_State <= Sta_37; 
						RD_E <= '0';
					end if;
				else											-- ｽｽｽﾌデｽoｽCｽXｽｽｽｽｽﾈゑｿｽｽﾌで会ｿｽｽｽｽﾈゑｿｽ
					I2C_State <= Sta_ED1; 
				end if;

			when Sta_09 =>		-- SCK No9  (Ack)
				I2C_State <= Sta_0A; 

------Write Job ----------
----- Address Set(H) --------
			when Sta_0A =>		--SCK No10
				Address(15) <= I_SDT;
				I2C_State <= Sta_0B; 
			when Sta_0B =>		--SCK No11
				Address(14) <= I_SDT;
				I2C_State <= Sta_0C; 
			when Sta_0C =>		--SCK No12
				Address(13) <= I_SDT;
				I2C_State <= Sta_0D; 
			when Sta_0D =>		--SCK No13
				Address(12) <= I_SDT;
				I2C_State <= Sta_0E; 
			when Sta_0E =>		--SCK No14
				Address(11) <= I_SDT;
				I2C_State <= Sta_0F; 
			when Sta_0F =>		--SCK No15
				Address(10) <= I_SDT;
				I2C_State <= Sta_10; 
			when Sta_10 =>		--SCK No16
				Address(9) <= I_SDT;
				I2C_State <= Sta_11; 
			when Sta_11 =>		--SCK No17
				Address(8) <= I_SDT;
				I2C_State <= Sta_12; 

----- Ack --------
			when Sta_12 =>		-- SCK No18  (Ack)
				I2C_State <= Sta_13; 

----- Address Set(L) --------
			when Sta_13 =>		--SCK No19
				Address(7) <= I_SDT;
				I2C_State <= Sta_14; 
			when Sta_14 =>		--SCK No20
				Address(6) <= I_SDT;
				I2C_State <= Sta_15; 
			when Sta_15 =>		--SCK No21
				Address(5) <= I_SDT;
				I2C_State <= Sta_16; 
			when Sta_16 =>		--SCK No22
				Address(4) <= I_SDT;
				I2C_State <= Sta_17; 
			when Sta_17 =>		--SCK No23
				Address(3) <= I_SDT;
				I2C_State <= Sta_18; 
			when Sta_18 =>		--SCK No24
				Address(2) <= I_SDT;
				I2C_State <= Sta_19; 
			when Sta_19 =>		--SCK No25
				Address(1) <= I_SDT;
				I2C_State <= Sta_1A; 
			when Sta_1A =>		--SCK No26
				Address(0) <= I_SDT;
				I2C_State <= Sta_1B; 
				
----- Ack --------
			when Sta_1B =>		-- SCK No27  (Ack)
				I2C_State <= Sta_1C; 
				
				
----- Data Set --------
			when Sta_1C =>		--SCK No28
				Data_I(7) <= I_SDT;
				I2C_State <= Sta_1D; 
			when Sta_1D =>		--SCK No29
				Data_I(6) <= I_SDT;
				I2C_State <= Sta_1E; 
			when Sta_1E =>		--SCK No30
				Data_I(5) <= I_SDT;
				I2C_State <= Sta_1F; 
			when Sta_1F =>		--SCK No31
				Data_I(4) <= I_SDT;
				I2C_State <= Sta_20; 
			when Sta_20 =>		--SCK No32
				Data_I(3) <= I_SDT;
				I2C_State <= Sta_21; 
			when Sta_21 =>		--SCK No33
				Data_I(2) <= I_SDT;
				I2C_State <= Sta_22; 
			when Sta_22 =>		--SCK No34
				Data_I(1) <= I_SDT;
				I2C_State <= Sta_23; 
			when Sta_23 =>		--SCK No35
				Data_I(0) <= I_SDT;
				I2C_State <= Sta_24; 
				WR_E <= '0';

----- Ack --------
			when Sta_24 =>		-- SCK No36  (Ack)
				I2C_State <= Sta_1C; 
				WR_E <= '1';
				
			when Sta_25 =>		--SCK Noxx
				Data_I(7) <= I_SDT;
				I2C_State <= Sta_1D; 
				Address <= Address + '1';

				
				
				
-------------------------------------------------------------------Write Job Loop

--------Read Job --------
----- Data Read --------
			when Sta_37 =>		-- SCK No9  (Ack)
				DATA_O <= DATO;
				RD_E <= '1';
				I2C_State <= Sta_38; 
			when Sta_38 =>		--SCK No10	(D7)
				I2C_State <= Sta_39; 
			when Sta_39 =>		--SCK No11	(D6)
				I2C_State <= Sta_3A; 
			when Sta_3A =>		--SCK No12	(D5)
				I2C_State <= Sta_3B; 
			when Sta_3B =>		--SCK No13	(D4)
				I2C_State <= Sta_3C; 
			when Sta_3C =>		--SCK No14	(D3)
				I2C_State <= Sta_3D; 
			when Sta_3D =>		--SCK No15	(D2)
				I2C_State <= Sta_3E; 
			when Sta_3E =>		--SCK No16	(D1)
				I2C_State <= Sta_3F; 
				Address <= Address + '1';
			when Sta_3F =>		--SCK No17  (D0)
				I2C_State <= Sta_40; 
				RD_E <= '0';
			when Sta_40 =>		--SCK No18  (NoAck)
				if(I_SDT = '1') then		--No-Ack ｽIｽｽ
					RD_E <= '1';
					I2C_State <= Sta_00; 
				else						--Ack ｽｽｽｽｽｽｽｽ
					RD_E <= '1';
					I2C_State <= Sta_38; 
				end if;

			when others =>
				I2C_State <= Sta_00; 
		end case;
	end if;


	if(Reset = '0') then
		O_SDT <= 'Z';
		D_Hiz <= '1';
-- 10036		DOUT <=  '0';
	elsif(I_SCK'event and I_SCK = '0')then
		case I2C_State is
			when Sta_09 =>		--Ack
				O_SDT <= '0';
				D_Hiz <= '0';
			when Sta_12 =>		--Ack
				O_SDT <= '0';
				D_Hiz <= '0';
			when Sta_1B =>		--Ack
				O_SDT <= '0';
				D_Hiz <= '0';
			when Sta_37 =>		--Ack
				O_SDT <= '0';
				D_Hiz <= '0';
			when Sta_38 =>		--D7
--	10036			DOUT <=  '1';
				O_SDT <= Data_O(7);
				D_Hiz <= '0';
			when Sta_39 =>		--D6
				O_SDT <= Data_O(6);
				D_Hiz <= '0';
			when Sta_3A =>		--D5
				O_SDT <= Data_O(5);
				D_Hiz <= '0';
			when Sta_3B =>		--D4
				O_SDT <= Data_O(4);
				D_Hiz <= '0';
			when Sta_3C =>		--D3
				O_SDT <= Data_O(3);
				D_Hiz <= '0';
			when Sta_3D =>		--D2
				O_SDT <= Data_O(2);
				D_Hiz <= '0';
			when Sta_3E =>		--D1
				O_SDT <= Data_O(1);
				D_Hiz <= '0';
			when Sta_3F =>		--D0
				O_SDT <= Data_O(0);
				D_Hiz <= '0';
--	10036			DOUT <=  '0';
			when Sta_40 =>		--No Ack
				O_SDT <= 'Z';
				D_Hiz <= '1';
			when others =>
				O_SDT <= 'Z';
				D_Hiz <= '1';
		end case;
	end if;

	
end process;


END I2C_Core_16_architecture;
