-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel MegaCore Function License Agreement, or other
-- applicable license agreement, including, without limitation,
-- that your use is for the sole purpose of programming logic
-- devices manufactured by Intel and sold by Intel or its
-- authorized distributors.  Please refer to the applicable
-- agreement for further details.


-- Generated by Quartus Prime Version 17.0 (Build Build 595 04/25/2017)
-- Created on Fri Apr 13 11:02:52 2018

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.std_logic_arith.all;

--  Entity Declaration

ENTITY I2C_CLK_IN_8 IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
CLK100 : IN STD_LOGIC;
RESET : IN STD_LOGIC;
ADR : IN STD_LOGIC_VECTOR(15 downto 0);
DATI : IN STD_LOGIC_VECTOR(7 downto 0);
RDe : IN STD_LOGIC;
WRe : IN STD_LOGIC;
DATO : OUT STD_LOGIC_VECTOR(7 downto 0);
TPOUT : IN STD_LOGIC_VECTOR(15 downto 0);
CLKI : IN STD_LOGIC_VECTOR(7 downto 0)
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END I2C_CLK_IN_8;


--  Architecture Body

ARCHITECTURE I2C_CLK_IN_8_architecture OF I2C_CLK_IN_8 IS

	signal	START			: std_logic;				-- 0:stop / 1:start


	signal	FILTERVAL	: std_logic_vector( 3 downto 0 );
	signal	FILTERSEL	: std_logic_vector( 1 downto 0 );
	signal	FILTERCLK	: std_logic;

	signal	WDTHCLK		: std_logic;
	signal	WDTHCLKSEL	: std_logic_vector( 1 downto 0 );
	signal	WDTHMODE		: std_logic_vector( 1 downto 0 );

	type reg32	is array ( 0 to 7 ) of std_logic_vector( 31 downto 0 );
	signal	FREQCNT		: reg32;
	signal	WDTH			: reg32;
	signal	WDTHHI		: reg32;
	
	signal	BASE_VALID_CNT	: std_logic_vector( 31 downto 0 );
	signal	MODE				: std_logic_vector( 1 downto 0 );	-- 00:1ms / 01:100ms / 10:1s / 11:ever
	signal	BASE_VALID		: std_logic;
	signal	BASE_VALID_CMP	: std_logic_vector( 31 downto 0 );	-- 1ms( 0x00989680 x 0.01us = 1000000us(100msec) )
	
	signal	CLK10MHz			: std_logic;
	signal	CLK1MHz			: std_logic;
	signal	CLK10KHz			: std_logic;
	
	signal	FFREQ				: std_logic_vector( 7 downto 0 );	-- after filter

	type reg2	is array ( 0 to 7 ) of std_logic_vector( 1 downto 0 );
	signal	WDSTA				: reg2;
	signal	WDSTART			: std_logic_vector( 7 downto 0 );
	signal	WDEND				: std_logic_vector( 7 downto 0 );
	signal	WDGATE			: std_logic_vector( 7 downto 0 );
	
	
	-- DIVCLK --
	COMPONENT	DIVCLK
		port
		(
			RESET		:	IN		STD_LOGIC;
			CLKIN		:	IN		STD_LOGIC;
			DIV		:	IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			CLKOUT	:	OUT	STD_LOGIC
		);
	END COMPONENT;
	
	-- FILTER --
	COMPONENT	FILTER
		port
		(
			RESET		:	IN		STD_LOGIC;
			FREQ		:	IN		STD_LOGIC;
			FILTERCLK:	IN		STD_LOGIC;
			FILTER	:	IN		STD_LOGIC_VECTOR ( 3 downto 0 );
			FFREQ		:	OUT	STD_LOGIC
		);
	END COMPONENT;
	
	-- FREQUENCY --
	COMPONENT	FREQUENCY
		PORT
		(
			RESET		:	IN		STD_LOGIC;
			START		:	IN		STD_LOGIC;
			CLKI		:	IN		STD_LOGIC;
			VALID		:	IN		STD_LOGIC;
			FREQVAL	:	OUT	STD_LOGIC_VECTOR ( 31 downto 0 )
		);	
	END COMPONENT;

	-- WIDTH_CTRL --
	COMPONENT	WIDTH_CTRL
		PORT
		(
			RESET		:	IN		STD_LOGIC;
			START		:	IN		STD_LOGIC;
			CLK		:	IN		STD_LOGIC;
			WIDTHMODE:	IN		STD_LOGIC_VECTOR ( 1 downto 0 );
			WIDTHSIG	:	IN		STD_LOGIC;
			
			WDSTART	:	OUT	STD_LOGIC;
			WDENd		:	OUT	STD_LOGIC;
			WDSTA		:	OUT	STD_LOGIC_VECTOR ( 1 downto 0 )
		);
	END COMPONENT;

	-- WIDTH_COUNT --
	COMPONENT	WIDTH_COUNT
		PORT
		(
			RESET		:	IN		STD_LOGIC;
			START		:	IN		STD_LOGIC;
			WDGATE	:	IN		STD_LOGIC;
			WDTHCLK	:	IN		STD_LOGIC;
			CLKI		:	IN		STD_LOGIC;

			WDTHCNT	:	OUT	STD_LOGIC_VECTOR ( 31 downto 0 );
			WDTHHI	:	OUT	STD_LOGIC_VECTOR ( 31 downto 0 )
		);
	END COMPONENT;
	
	
	
BEGIN
	
	process ( 
		RESET,
		MODE,
		DATI,
		RDe,
		WRe,
		ADR
	)
	begin
		if ( RESET = '0' ) then
			DATO			<= ( others => 'Z' );
			START			<= '0';
			FILTERSEL	<= ( others => '0' );
			WDTHCLKSEL	<= ( others => '0' );
			WDTHMODE		<= ( others => '0' );
			FILTERVAL	<= ( others => '0' );
			MODE			<= "01";
		else
		
			-- Reg Read Operation
			if 	( RDe = '0' and WRe = '1' ) then
			
				-- Freq Count Read -- 4Byte(32Bit)
				if		( X"0100" <= ADR and ADR <= X"011F" ) then
					-- ADR bit 4..2 is 000:(CKI0) 001:(CKI1) 010:(CKI2) ... 111:(CKI7)
					DATO <= FREQCNT ( CONV_INTEGER( ADR ( 4 downto 2 ) ) ) 
									( ( ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) * 8 ) );
									
				-- WIDTH Count Read -- 4Byte(32bit)
				elsif	( X"0120" <= ADR and ADR <= X"013F" ) then
					-- ADR bit 4..2 is 000:(CKI0) 001:(CKI1) 010:(CKI2) ... 111:(CKI7)
					DATO <= WDTH ( CONV_INTEGER( ADR ( 4 downto 2 ) ) ) 
									( ( ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) * 8 ) );
				
				-- WIDTH-Hi Count Read -- 4Byte(32bit)
				elsif ( X"0140" <= ADR and ADR <= X"015F" ) then
					-- ADR bit 4..2 is 000:(CKI0) 001:(CKI1) 010:(CKI2) ... 111:(CKI7)
					DATO <= WDTHHI ( CONV_INTEGER( ADR ( 4 downto 2 ) ) ) 
									( ( ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) * 8 ) );
				
				elsif ( X"0160" = ADR ) then
					DATO ( 7 ) 				<= START;
					DATO ( 6 ) 				<= '0';		-- n/a
					DATO ( 5 downto 4 )	<= FILTERSEL;
					DATO ( 3 downto 2 )	<= WDTHCLKSEL;
					DATO ( 1 downto 0 )	<= WDTHMODE;
		
				elsif ( X"0161" = ADR ) then
					DATO ( 7 downto 4 )	<= FILTERVAL;
					DATO ( 3 downto 2 )	<= ( others=> '0' );
					DATO ( 1 downto 0 )	<= MODE;
				else
					DATO <= ( others=> 'Z' );
				
				end if;
			
			-- Reg Write Operation
			elsif ( RDe = '1' and WRe = '0' ) then
				if		( X"0100" <= ADR and ADR <= X"011F" ) then
					-- ADR bit 4..2 is 000:(CKI0) 001:(CKI1) 010:(CKI2) ... 111:(CKI7)
					NULL;
					-- WIDTH Count Read -- 4Byte(32bit)
				elsif	( X"0120" <= ADR and ADR <= X"013F" ) then
					NULL;
				-- WIDTH-Hi Count Read -- 4Byte(32bit)
				elsif ( X"0140" <= ADR and ADR <= X"015F" ) then
					NULL;
				elsif ( X"0160" = ADR ) then
					START			<= DATI ( 7 );
					FILTERSEL	<= DATI ( 5 downto 4 );
					WDTHCLKSEL	<= DATI ( 3 downto 2 );
					WDTHMODE		<= DATI ( 1 downto 0 );
		
				elsif ( X"0161" = ADR ) then
					FILTERVAL	<= DATI ( 7 downto 4 );
					MODE			<= DATI ( 1 downto 0 );
				else
					NULL;
				end if;
				DATO <= ( others => 'Z' );
			else
				DATO <= ( others => 'Z' );
			end if;
		end if;
	end process;
	


	-- BASE Valid for FREQ(100MHz) --
	process (
		RESET,
		CLK100,
		START,
		MODE
	)
	begin
		if ( RESET = '0' ) then
			BASE_VALID_CNT		<= (others=>'0');	-- 0 clear
			BASE_VALID			<= '0';

		elsif ( START = '0' ) then
			
			case MODE is
				when "00" =>
					BASE_VALID_CMP	<= X"000186A0";		--    1msec
					BASE_VALID		<= '0';
				when "01" =>
					BASE_VALID_CMP	<= X"00989680";		--  100msec
					BASE_VALID		<= '0';
				when "10" =>
					BASE_VALID_CMP	<= X"05F5E100";		-- 1000msec
					BASE_VALID		<= '0';
				when "11" =>
					BASE_VALID_CMP	<= X"FFFFFFFF";		-- ever
					BASE_VALID		<= '1';
			end case;
			BASE_VALID_CNT		<= (others=>'0');	-- 0 clear
			
		elsif ( CLK100'event and CLK100 ='1' ) then		-- 100MHz
			
			if ( MODE /= "11" ) then
				if ( BASE_VALID_CNT < BASE_VALID_CMP ) then
					BASE_VALID_CNT <= BASE_VALID_CNT + '1';
					BASE_VALID <= '1';
				else
					BASE_VALID <= '0';
				end if;
			else
				BASE_VALID	<= '1';
			end if;
		else
			NULL;
		end if;
		
	end process;

	
	-- 10MHz
	C0: DIVCLK
		port map ( RESET, CLK100, X"000A", CLK10MHz );
	-- 1MHz
	C1: DIVCLK
		port map ( RESET, CLK10MHz, X"000A", CLK1MHz );
	-- 10KHz
	C2: DIVCLK
		port map ( RESET, CLK1MHz, X"0064", CLK10KHz );


		
		
	process(
		RESET,
		FILTERSEL,
		CLK100,
		CLK10MHz,
		CLK1MHz
	)
	begin
		if ( RESET = '0' ) then
			FILTERCLK		<= '0';
		else
			case FILTERSEL is
			when "00" =>
				FILTERCLK <= CLK100;
			when "01" =>
				FILTERCLK <= CLK10MHz;
			when "10" =>
				FILTERCLK <= CLK1MHZ;
			when "11" =>
				FILTERCLK <= '0';
			end case;
	
		end if;
	end process;
	
	
	-- FILTER
	FILTER0: FILTER
		port map ( RESET, CLKI ( 0 ), FILTERCLK, FILTERVAL, FFREQ ( 0 ) );
	FILTER1: FILTER
		port map ( RESET, CLKI ( 1 ), FILTERCLK, FILTERVAL, FFREQ ( 1 ) );
	FILTER2: FILTER
		port map ( RESET, CLKI ( 2 ), FILTERCLK, FILTERVAL, FFREQ ( 2 ) );
	FILTER3: FILTER
		port map ( RESET, CLKI ( 3 ), FILTERCLK, FILTERVAL, FFREQ ( 3 ) );
	FILTER4: FILTER
		port map ( RESET, CLKI ( 4 ), FILTERCLK, FILTERVAL, FFREQ ( 4 ) );
	FILTER5: FILTER
		port map ( RESET, CLKI ( 5 ), FILTERCLK, FILTERVAL, FFREQ ( 5 ) );
	FILTER6: FILTER
		port map ( RESET, CLKI ( 6 ), FILTERCLK, FILTERVAL, FFREQ ( 6 ) );
	FILTER7: FILTER
		port map ( RESET, CLKI ( 7 ), FILTERCLK, FILTERVAL, FFREQ ( 7 ) );
		
	-- FREQUENCY
	FREQUENCY0 : FREQUENCY
		port map ( RESET, START, FFREQ ( 0 ), BASE_VALID, FREQCNT ( 0 ) );
	FREQUENCY1 : FREQUENCY
		port map ( RESET, START, FFREQ ( 1 ), BASE_VALID, FREQCNT ( 1 ) );
	FREQUENCY2 : FREQUENCY
		port map ( RESET, START, FFREQ ( 2 ), BASE_VALID, FREQCNT ( 2 ) );
	FREQUENCY3 : FREQUENCY
		port map ( RESET, START, FFREQ ( 3 ), BASE_VALID, FREQCNT ( 3 ) );
	FREQUENCY4 : FREQUENCY
		port map ( RESET, START, FFREQ ( 4 ), BASE_VALID, FREQCNT ( 4 ) );
	FREQUENCY5 : FREQUENCY
		port map ( RESET, START, FFREQ ( 5 ), BASE_VALID, FREQCNT ( 5 ) );
	FREQUENCY6 : FREQUENCY
		port map ( RESET, START, FFREQ ( 6 ), BASE_VALID, FREQCNT ( 6 ) );
	FREQUENCY7 : FREQUENCY
		port map ( RESET, START, FFREQ ( 7 ), BASE_VALID, FREQCNT ( 7 ) );

	-- WIDTH_CTRL
	WIDTH_CTRL0: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 0 ), WDSTART ( 0 ), WDEND ( 0 ), WDSTA ( 0 ) );
	WIDTH_CTRL1: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 1 ), WDSTART ( 1 ), WDEND ( 1 ), WDSTA ( 1 ) );
	WIDTH_CTRL2: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 2 ), WDSTART ( 2 ), WDEND ( 2 ), WDSTA ( 2 ) );
	WIDTH_CTRL3: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 3 ), WDSTART ( 3 ), WDEND ( 3 ), WDSTA ( 3 ) );
	WIDTH_CTRL4: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 4 ), WDSTART ( 4 ), WDEND ( 4 ), WDSTA ( 4 ) );
	WIDTH_CTRL5: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 5 ), WDSTART ( 5 ), WDEND ( 5 ), WDSTA ( 5 ) );
	WIDTH_CTRL6: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 6 ), WDSTART ( 6 ), WDEND ( 6 ), WDSTA ( 6 ) );
	WIDTH_CTRL7: WIDTH_CTRL
		port map ( RESET, START, CLK100, WDTHMODE, FFREQ ( 7 ), WDSTART ( 7 ), WDEND ( 7 ), WDSTA ( 7 ) );

	WDGATE	<= WDSTART xor WDEND;
	
	
	process (
		RESET,
		WDTHCLKSEL,
		CLK100,
		CLK10MHZ,
		CLK1MHZ,
		CLK10KHZ
	)
	begin
		if ( RESET = '0' ) then
			WDTHCLK <= '0';
		else
			case WDTHCLKSEL is
				when "00" =>
					WDTHCLK		<= CLK100;
				when "01" =>
					WDTHCLK		<= CLK10MHZ;
				when "10" =>
					WDTHCLK		<= CLK1MHZ;
				when "11" =>
					WDTHCLK		<= CLK10KHZ;
				when others =>
					WDTHCLK		<= '0';
			end case;
		end if;
	end process;
		
	-- WIDTH_COUNT
	WIDTH_COUNT0: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 0 ), WDTHCLK, CLK100, WDTH ( 0 ), WDTHHI ( 0 ) );
	WIDTH_COUNT1: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 1 ), WDTHCLK, CLK100, WDTH ( 1 ), WDTHHI ( 1 ) );
	WIDTH_COUNT2: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 2 ), WDTHCLK, CLK100, WDTH ( 2 ), WDTHHI ( 2 ) );
	WIDTH_COUNT3: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 3 ), WDTHCLK, CLK100, WDTH ( 3 ), WDTHHI ( 3 ) );
	WIDTH_COUNT4: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 4 ), WDTHCLK, CLK100, WDTH ( 4 ), WDTHHI ( 4 ) );
	WIDTH_COUNT5: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 5 ), WDTHCLK, CLK100, WDTH ( 5 ), WDTHHI ( 5 ) );
	WIDTH_COUNT6: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 6 ), WDTHCLK, CLK100, WDTH ( 6 ), WDTHHI ( 6 ) );
	WIDTH_COUNT7: WIDTH_COUNT
		port map ( RESET, START, WDGATE( 7 ), WDTHCLK, CLK100, WDTH ( 7 ), WDTHHI ( 7 ) );
	



	
	
	
	
END I2C_CLK_IN_8_architecture;
