-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2017  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel MegaCore Function License Agreement, or other
-- applicable license agreement, including, without limitation,
-- that your use is for the sole purpose of programming logic
-- devices manufactured by Intel and sold by Intel or its
-- authorized distributors.  Please refer to the applicable
-- agreement for further details.


-- Generated by Quartus Prime Version 17.0 (Build Build 595 04/25/2017)
-- Created on Sat Jun 02 13:43:37 2018

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.std_logic_arith.all;


--  Entity Declaration

ENTITY PatternGenerate16A IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
	RESET 		: IN		STD_LOGIC;
	CLK 			: IN		STD_LOGIC;
	ADR 			: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
	RDe 			: IN		STD_LOGIC;
	WRe 			: IN		STD_LOGIC;
	DATI 			: IN		STD_LOGIC_VECTOR (  7 downto 0 );
	DATO 			: OUT		STD_LOGIC_VECTOR (  7 downto 0 );
	TPOUT 		: OUT		STD_LOGIC_VECTOR ( 15 downto 0 );
	-- 16ch -> 8ch
--	PATGEN 		: OUT		STD_LOGIC_VECTOR ( 15 downto 0 )
	PATGEN 		: OUT		STD_LOGIC_VECTOR (  7 downto 0 )
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END PatternGenerate16A;


--  Architecture Body

ARCHITECTURE PatternGenerate16A_architecture OF PatternGenerate16A IS

	signal		MODULEVER	: std_logic_vector ( 31 downto 0 ) := X"20180619";

	signal		D_HiZ			: std_logic;				-- データ Hiz
	signal		DATAO			: std_logic_vector ( 7 downto 0 );

	signal		START			: std_logic;
	signal		SOFTRES		: std_logic;
--	signal		OutEnable	: std_logic_vector ( 15 downto 0 );
	signal		OutEnable	: std_logic_vector (  7 downto 0 );						-- 16ch -> 8ch
	signal		EOF			: std_logic;
	
--	type reg16x16	is array ( 0 to 15 ) of std_logic_vector( 15 downto 0 );
	type reg16x16	is array ( 0 to 7 ) of std_logic_vector( 15 downto 0 );		-- 16ch -> 8ch
	signal		CountNow		: reg16x16;
	signal		WidthSize	: reg16x16;
	signal		UpPosition	: reg16x16;
	signal		DownPosition: reg16x16;
	signal		CycleSize	: reg16x16;
	signal		StartCount	: reg16x16;
	
	-- for BASE CLOCK module ( 1MHz GEN )
	signal		BaseClkWidth: std_logic_vector( 15 downto 0 ) := X"000C";		-- 24MHz x 12 = 0.5usec
	signal		BaseClkCnt	: std_logic_vector( 15 downto 0 );
	signal		BaseClk		: std_logic := '0';
	signal		EndOfFlag	: std_logic_Vector( 15 downto 0 );
	
	
	COMPONEnT	GENERATOR
		PORT
		(
			RESET				: IN		STD_LOGIC;
			SOFTRES			: IN		STD_LOGIC;
			BASECLK			: IN		STD_LOGIC;
			OutEnable		: IN		STD_LOGIC;
			START				: IN		STD_LOGIC;
			WidthSize		: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			UpPosition		: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			DownPosition	: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			CycleSize		: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			StartCount		: IN		STD_LOGIC_VECTOR ( 15 downto 0 );
			CountNow			: OUT		STD_LOGIC_VECTOR ( 15 downto 0 );
			EOF				: OUT		STD_LOGIC;
			GenOut			: OUT		STD_LOGIC
		);	
	END COMPONENT;
--	signal		Output	: OUT		STD_LOGIC_VECTOR ( 15 downto 0 );
	
	
BEGIN
--	TPOUT									<= ( others => '0' );
	TPOUT ( 0 )							<= BASECLK;
	TPOUT ( 15 downto 1 )			<= ( others => '0' );
	DATO									<= ( Others => 'Z' ) when D_Hiz = '1' else DATAO;

	process (
		RESET
	)
	begin
		
		if ( RESET = '0' ) then
			D_Hiz							<= '1';
			
			START							<= '0';
			SOFTRES						<= '0';
			OutEnable					<= ( others => '0' );
	
			-- 16ch -> 8ch
--			for i in 0 to 15 loop
			for i in 0 to  7 loop
				WidthSize ( i )					<= ( others => '0' );
				UpPosition ( i )					<= X"0000";
				DownPosition ( i )				<= ( others => '0' );
				CycleSize ( i )					<= X"FFFF";
				StartCount ( i )					<= X"0000";
			end loop;
		else
			
			if		( RDe = '0' and WRe = '1' ) then
			-- Read 
				if		( X"B0C0" = ADR ) then
					DATAO ( 7 )				<= SOFTRES;
					DATAO ( 6 ) 			<= '0';				-- N/A
					DATAO ( 5 ) 			<= '0';				-- N/A
					DATAO ( 4 ) 			<= '0';				-- N/A
					DATAO ( 3 ) 			<= EOF;
					DATAO ( 2 ) 			<= '0';				-- N/A
					DATAO ( 1 ) 			<= '0';				-- N/A
					DATAO ( 0 ) 			<= START;
					D_Hiz						<= '0';
					
				elsif	( X"B0C2" = ADR ) then
					DATAO					<= OutEnable (  7 downto 0 );
					D_Hiz					<= '0';

				-- 16ch -> 8ch
--				elsif ( X"B0C3" = ADR ) then
--					DATAO					<= OutEnable ( 15 downto 8 );
--					D_Hiz					<= '0';
--

				-- 16ch -> 8ch
--				elsif ( X"B000" <= ADR and ADR <= X"B01F" ) then
--					DATAO					<= CountNow ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
				elsif ( X"B000" <= ADR and ADR <= X"B00F" ) then
					DATAO					<= CountNow ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
					D_Hiz					<= '0';
					
				-- 16ch -> 8ch
--				elsif ( X"B020" <= ADR and ADR <= X"B03F" ) then
--					DATAO					<= WidthSize ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );		
				elsif ( X"B020" <= ADR and ADR <= X"B02F" ) then
					DATAO					<= WidthSize ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );		
					D_Hiz					<= '0';
				
				-- 16ch -> 8ch
--				elsif ( X"B040" <= ADR and ADR <= X"B05F" ) then
--					DATAO					<= UpPosition ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
				elsif ( X"B040" <= ADR and ADR <= X"B04F" ) then
					DATAO					<= UpPosition ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
					D_Hiz					<= '0';
				
				-- 16ch -> 8ch
--				elsif ( X"B060" <= ADR and ADR <= X"B07F" ) then
--					DATAO					<= DownPosition ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );	
				elsif ( X"B060" <= ADR and ADR <= X"B06F" ) then
					DATAO					<= DownPosition ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );	
					D_Hiz					<= '0';
				
				-- 16ch -> 8ch
--				elsif ( X"B080" <= ADR and ADR <= X"B09F" ) then
--					DATAO					<= CycleSize ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
				elsif ( X"B080" <= ADR and ADR <= X"B08F" ) then
					DATAO					<= CycleSize ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
					D_Hiz					<= '0';
				
				-- 16ch -> 8ch
--				elsif ( X"B0A0" <= ADR and ADR <= X"B0BF" ) then
--					DATAO					<= StartCount ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
				elsif ( X"B0A0" <= ADR and ADR <= X"B0AF" ) then
					DATAO					<= StartCount ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 );
					D_Hiz					<= '0';
				
				elsif ( X"B0F0" <= ADR and ADR <= X"B0F3" ) then
				-- Version Reg
					DATAO					<= MODULEVER ( ( ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) + 1 ) * 8 - 1 ) downto ( CONV_INTEGER ( ADR ( 1 downto 0 ) ) * 8 ) );
					D_Hiz					<= '0';
				else
					D_Hiz					<= '1';
				end if;

			elsif ( RDe = '1' and WRe = '0' ) then
			-- Write
				if		( X"B0C0" = ADR ) then
					SOFTRES					<= DATI ( 7 );
					START						<= DATI ( 0 );
				elsif	( X"B0C2" = ADR ) then
					OutEnable (  7 downto 0 )	<= DATI;
				
				-- 16ch -> 8ch
--				elsif ( X"B0C3" = ADR ) then
--					OutEnable ( 15 downto 8 )	<= DATI;
					
				elsif ( X"B000" <= ADR and ADR <= X"B01F" ) then
					NULL;

				-- 16ch -> 8ch
--				elsif ( X"B020" <= ADR and ADR <= X"B03F" ) then
--					WidthSize ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				elsif ( X"B020" <= ADR and ADR <= X"B02F" ) then
					WidthSize ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;

				-- 16ch -> 8ch
--				elsif ( X"B040" <= ADR and ADR <= X"B05F" ) then
--					UpPosition ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				elsif ( X"B040" <= ADR and ADR <= X"B04F" ) then
					UpPosition ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				
				-- 16ch -> 8ch
--				elsif ( X"B060" <= ADR and ADR <= X"B07F" ) then
--					DownPosition ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				elsif ( X"B060" <= ADR and ADR <= X"B06F" ) then
					DownPosition ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;

				-- 16ch -> 8ch
--				elsif ( X"B080" <= ADR and ADR <= X"B09F" ) then
--					CycleSize ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				elsif ( X"B080" <= ADR and ADR <= X"B08F" ) then
					CycleSize ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;

				-- 16ch -> 8ch
--				elsif ( X"B0A0" <= ADR and ADR <= X"B0BF" ) then
--					StartCount ( CONV_INTEGER ( ADR ( 4 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;
				elsif ( X"B0A0" <= ADR and ADR <= X"B0AF" ) then
					StartCount ( CONV_INTEGER ( ADR ( 3 downto 1 ) ) ) ( ( CONV_INTEGER ( ADR ( 0 ) ) + 1 ) * 8 - 1   downto CONV_INTEGER ( ADR ( 0 ) ) * 8 ) <= DATI;

				else
					NULL;
				end if;
				D_Hiz						<= '1';
			else
				D_Hiz						<= '1';
			end if;
			
--			PATGEN ( 0 )				<= CLK;
--			PATGEN ( 15 downto 1 )	<= ( others => '0' );
			
		end if;
		
	end process;



	-- Base Clock 1MHz Module @ 24MHz -- 
	process (
		RESET,
		CLK
	)
	begin
		if ( RESET = '0' ) then
			BaseClkCnt	<= X"0000";
			BaseClk		<= '0';
		elsif ( CLK'event and CLK = '1' ) then
			BaseClkCnt <= BaseClkCnt + '1';
			
			if ( BaseClkCnt >= (BaseClkWidth-1) ) then
				BaseClk <= not BaseClk;
				BaseClkCnt <= (others=>'0');		-- 0 clear
			else
				NULL;
			end if;
		else
			NULL;
		end if;
	end process;
	
	
	GERERATOR0:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  0 ), START, WidthSize (  0 ), UpPosition (  0 ), DownPosition (  0 ), CycleSize (  0 ), StartCount (  0 ), CountNow (  0 ), EndOfFlag (  0 ), PATGEN (  0 ) );
	GERERATOR1:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  1 ), START, WidthSize (  1 ), UpPosition (  1 ), DownPosition (  1 ), CycleSize (  1 ), StartCount (  1 ), CountNow (  1 ), EndOfFlag (  1 ), PATGEN (  1 ) );
	GERERATOR2:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  2 ), START, WidthSize (  2 ), UpPosition (  2 ), DownPosition (  2 ), CycleSize (  2 ), StartCount (  2 ), CountNow (  2 ), EndOfFlag (  2 ), PATGEN (  2 ) );
	GERERATOR3:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  3 ), START, WidthSize (  3 ), UpPosition (  3 ), DownPosition (  3 ), CycleSize (  3 ), StartCount (  3 ), CountNow (  3 ), EndOfFlag (  3 ), PATGEN (  3 ) );
	GERERATOR4:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  4 ), START, WidthSize (  4 ), UpPosition (  4 ), DownPosition (  4 ), CycleSize (  4 ), StartCount (  4 ), CountNow (  4 ), EndOfFlag (  4 ), PATGEN (  4 ) );
	GERERATOR5:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  5 ), START, WidthSize (  5 ), UpPosition (  5 ), DownPosition (  5 ), CycleSize (  5 ), StartCount (  5 ), CountNow (  5 ), EndOfFlag (  5 ), PATGEN (  5 ) );
	GERERATOR6:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  6 ), START, WidthSize (  6 ), UpPosition (  6 ), DownPosition (  6 ), CycleSize (  6 ), StartCount (  6 ), CountNow (  6 ), EndOfFlag (  6 ), PATGEN (  6 ) );
	GERERATOR7:
		Generator
			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  7 ), START, WidthSize (  7 ), UpPosition (  7 ), DownPosition (  7 ), CycleSize (  7 ), StartCount (  7 ), CountNow (  7 ), EndOfFlag (  7 ), PATGEN (  7 ) );
--	GERERATOR8:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  8 ), START, WidthSize (  8 ), UpPosition (  8 ), DownPosition (  8 ), CycleSize (  8 ), StartCount (  8 ), CountNow (  8 ), EndOfFlag (  8 ), PATGEN (  8 ) );
--	GERERATOR9:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable (  9 ), START, WidthSize (  9 ), UpPosition (  9 ), DownPosition (  9 ), CycleSize (  9 ), StartCount (  9 ), CountNow (  9 ), EndOfFlag (  9 ), PATGEN (  9 ) );
--	GERERATOR10:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 10 ), START, WidthSize ( 10 ), UpPosition ( 10 ), DownPosition ( 10 ), CycleSize ( 10 ), StartCount ( 10 ), CountNow ( 10 ), EndOfFlag ( 10 ), PATGEN ( 10 ) );
--	GERERATOR11:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 11 ), START, WidthSize ( 11 ), UpPosition ( 11 ), DownPosition ( 11 ), CycleSize ( 11 ), StartCount ( 11 ), CountNow ( 11 ), EndOfFlag ( 11 ), PATGEN ( 11 ) );
--	GERERATOR12:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 12 ), START, WidthSize ( 12 ), UpPosition ( 12 ), DownPosition ( 12 ), CycleSize ( 12 ), StartCount ( 12 ), CountNow ( 12 ), EndOfFlag ( 12 ), PATGEN ( 12 ) );
--	GERERATOR13:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 13 ), START, WidthSize ( 13 ), UpPosition ( 13 ), DownPosition ( 13 ), CycleSize ( 13 ), StartCount ( 13 ), CountNow ( 13 ), EndOfFlag ( 13 ), PATGEN ( 13 ) );
--	GERERATOR14:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 14 ), START, WidthSize ( 14 ), UpPosition ( 14 ), DownPosition ( 14 ), CycleSize ( 14 ), StartCount ( 14 ), CountNow ( 14 ), EndOfFlag ( 14 ), PATGEN ( 14 ) );
--	GERERATOR15:
--		Generator
--			port	map	( RESET, SOFTRES, BaseClk, OutEnable ( 15 ), START, WidthSize ( 15 ), UpPosition ( 15 ), DownPosition ( 15 ), CycleSize ( 15 ), StartCount ( 15 ), CountNow ( 15 ), EndOfFlag ( 15 ), PATGEN ( 15 ) );
		
			
			
			
			
			
			
			
			
END PatternGenerate16A_architecture;
